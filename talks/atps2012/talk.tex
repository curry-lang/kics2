\documentclass[
,hyperref={pdfpagelabels=false}
]{beamer}
% Die Hyperref Option hyperref={pdfpagelabels=false} verhindert die Warnung:
% Package hyperref Warning: Option `pdfpagelabels' is turned off
% (hyperref)                because \thepage is undefined.
% Hyperref stopped early

\usepackage{agstyle}
\usepackage{currycode}
\usepackage{tikz}
\usepackage{listings}

\newcommand{\ergo}{$\Rightarrow$}
\newcommand{\todo}[1]{\fbox{\sc To do: #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title[Search Strategies for FLP]
{Search Strategies for Functional Logic Programming}

\date[ATPS 2012]{ATPS 2012, February 27}

\author[Hanus, Peemöller, \underline{Reck}]{%
\texorpdfstring
  {Michael Hanus \and Björn Peemöller \and \underline{Fabian Reck}}
  {Michael Hanus \and Björn Peemöller \and Fabian Reck}
}

\institute{Kiel University}

\begin{document}

\begin{frame}%---------------
\titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%$$

\section{Introduction}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Functional Logic Programming}
\begin{itemize}
\item combines features from functional and logic programming
  \begin{itemize}
   \item higher-order functions
   \item demand-driven evaluation
   \item non-determinism
   \item logic variables
  \end{itemize}
\item search for results
\item different search strategies
\end{itemize}
\end{frame}

\begin{frame}[fragile]%------------------------------------------------------
\frametitle{Curry}
\begin{columns}[t]

\begin{column}{.4\textwidth}
\begin{itemize}
\item functional logic programming language
\item non-strict semantics
\item Haskell-like syntax
\item extended with:
  \begin{itemize}
  \item non-determinism through overlapping rules
  \item free (logic) variables
  \item constraints and unification
  \end{itemize}
\end{itemize}
\end{column}

\begin{column}{.5\textwidth}
\begin{curry}%{Example}
(?) :: a -> a -> a
x ? _ = x
_ ? y = y

coin :: Int
coin = 1 ? 2

(++) :: [a] -> [a] -> [a]
[] ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)

last :: [a] -> a
last xs | (ys ++ [z]) =:= xs = z
  where ys, z free
\end{curry}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Curry implementations} % and their search strategies}
%Todo Tabelle , Zielsprache, Suchstrategien, extensible
%     KiCS2 einblenden
\begin{description}
\item[PAKCS] translates to Prolog, uses backtracking (DFS)
\item[MCC]   translates to C, DFS
\item[KiCS]  translates to unsafe Haskell, DFS and BFS
\item[KiCS2] translates to Haskell, DFS, BFS, IDS, PAR, easily extensible
\end{description}
\end{frame}

\section{Search Strategies}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Search implementation in KiCS2}

\begin{itemize}
\item based on an explicit representation of the search space
\item normal form computation lazily evaluates the search tree
      of an expression
\end{itemize}


\begin{columns}[t]
\begin{column}{0.45\textwidth}
\begin{curry}[Curry expression]
last [T,F] 
=> ys ++ [z] =:= [T,F] &> z 
   where ys, z free
\end{curry}
\end{column}

\begin{column}{0.45\textwidth}
\begin{block}{Corresponding search tree}
\begin{tikzpicture}
\node (qys)   at (2,4) {$\code{?}^{\code{ys}}$};
\node (f1)    at (1,3) {$\code{!}$}           ;
\node (qx)    at (3,3) {$\code{?}^{\code{x}}$} ;
\node (qxs)   at (2,2) {$\code{?}^{\code{xs}}$};
\node (f2)    at (4,2) {$\code{!}$}           ;
\node (qz)    at (1,1) {$\code{?}^{\code{z}}$} ;
\node (f3)    at (3,1) {$\code{!}$}           ;
\node (f4)    at (0,0) {$\code{!}$}           ;
\node (false) at (2,0) {$\code{F}$}           ;
\draw (qys) -- node[sloped,above]{\tiny{$\code{[]}$}}   (f1)   ;
\draw (qys) -- node[sloped,above]{\tiny{$\code{x:xs}$}} (qx)   ;
\draw (qx)  -- node[sloped,above]{\tiny{$\code{T}$}}    (qxs)  ;
\draw (qx)  -- node[sloped,above]{\tiny{$\code{F}$}}    (f2)   ;
\draw (qxs) -- node[sloped,above]{\tiny{$\code{[]}$}}   (qz)   ;
\draw (qxs) -- node[sloped,above]{\tiny{$\code{\_:\_}$}}(f3)   ;
\draw (qz)  -- node[sloped,above]{\tiny{$\code{T}$}}    (f4)   ;
\draw (qz)  -- node[sloped,above]{\tiny{$\code{F}$}}    (false);
\end{tikzpicture}
\end{block}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Search strategies}

\begin{itemize}
  \item based on tree representation of search space
  \item strategies only extract values from this search tree
  \item available strategies : depth-first, breadth-first, iterative deepening
\end{itemize}

\begin{haskell}[SearchTree]
data SearchTree a
  = None
  | One a
  | Choice (SearchTree a)
           (SearchTree a)
\end{haskell}

\begin{haskell}[Depth-first-search using SearchTree]
allValuesDFS :: SearchTree a -> [a]
allValuesDFS None         = []
allValuesDFS (One      x) = [x]
allValuesDFS (Choice x y) = allValuesDFS x ++ allValuesDFS y
\end{haskell}

\end{frame}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Exploration of search results}
\begin{haskell}[Interactive Top-Level Search]
printResults :: [a] -> IO ()
printResults []     = putStrLn "No more values"
printResults (x:xs) = do print x
                         putStr "More values? "
                         inp <- getLine
                         if inp == "yes" then printResults xs
                                         else return ()
                                         
getSearchTree exp >>= printResults . allValuesDFS %todo overlay BFS
\end{haskell}

%todo Folie für BFS

\begin{curryblock}{Encapsulated Search}
\begin{itemize}
\item search tree available in Curry
\item allows user-defined search strategies
\end{itemize}
\end{curryblock}
\end{frame}

\section{Benchmarks}

\begin{frame}%----------------------------------------------------------------
\frametitle{Benchmark: Non-Deterministic Permutation Sort}
Program: permutation sort of a list with 15 values
\begin{center}
\includegraphics[width=11cm]{gfx/permsort}
\end{center}
%\begin{itemize}
%\item DFS/eDFS: Overhead durch Suchbaum, Faktor 3
%\item $\text{IDS}_{10}^{+1}$ is very slow due to the linear search space
%\item $\text{eIDS}_{10}^{+1}$ profits from sharing the search tree
%\item IDS(+1)/IDS(*2): Overhead durch Gewährleistung von CTC
%\item IDS(*2)/eIDS(*2): Overhead durch Suchbaum, Faktor 1,5
%\item IDS(+1)/eIDS(+1). \todo{Aussage}
%\end{itemize}
\end{frame}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Benchmark: Last}
Program: find the last element of a 10,000 element list
\begin{center}
\includegraphics[width=11cm]{gfx/last}
\end{center}
% \todo{Laufzeit von BFS erklären}
\end{frame}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Benchmark: NDNums}
Program: find 29 in \code{g 0 where g n = g (n+1) ? (n ? g (n+1))}
\begin{center}
\includegraphics[width=11cm]{gfx/ndnums}
\end{center}
%\todo{IDS ist voll gut!}
\end{frame}

\section{Conclusion}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Conclusion}

\begin{block}{KiCS2}
\begin{itemize}
% \item Presentation of our approach to search
\item explicit representation of search space
\item search strategy selected by user
\item first practical results
\item avoid problems arising from the use of a fixed strategy
\item complete strategies are realistic alternatives to DFS
\item complete strategies support declarative programming style
\end{itemize}
\end{block}

\end{frame}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Future Work}

\begin{itemize}
\item analysis of more complex programs
\item analysis of memory behaviour
\item analysis of additional (parallel) strategies
\item program analysis to choose appropriate search strategy
\end{itemize}

\end{frame}

\end{document}
