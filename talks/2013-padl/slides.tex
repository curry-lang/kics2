\documentclass[10pt]{beamer}
%\documentclass[draft,10pt]{beamer} % for faster formatting
%\documentclass[handout,10pt]{beamer} % to produce a handout


\input{mhbeamer}

\usepackage{listings}
\lstset{mathescape=true,
        aboveskip=0.5ex,
        belowskip=0.5ex,
        showstringspaces=false, % no special string space
        basewidth=0.55em,
        basicstyle=\ttfamily,
      literate={=}{{=}}1
               {\\}{{$\lambda$}}1
               {\\\\}{{\char`\\\char`\\}}1
               {->}{{$\rightarrow{}\!\!\!$}}3
               {<-}{{$\leftarrow{}$}}2
               {\ .}{{$\circ$}}2 
               {\ .\ }{{$\circ$}}2
               {>>}{{>>}}2 
               {>>=}{{>>=}}4
               {|}{{$\mid$}}1
      }
\lstnewenvironment{curry}{}{}
\newcommand{\listline}{\vrule width0pt depth1.75ex}

\newcommand{\suc}{\mathit{success}}  % success
\newcommand{\Suc}{\mathtt{Success}}  % success type
\newcommand{\pre}[1]{#1^{pre}}  % precondition for a function
\newcommand{\post}[1]{#1^{post}} % postcondition for a function
\newcommand{\funset}{\ensuremath{_{\cal S}}}

\date{PADL 2013}
\author[Fabian Reck]{Fabian Reck\\[2ex]
{\small Joint work with Bernd Bra\ss{}el, Michael Hanus and Bj\"orn Peem\"oller}}
\institute[CAU Kiel]{Christian-Albrechts-University of Kiel\\
  Programming Languages and Compiler Construction}

\begin{document}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

\title[Implementing Equational Constraints in a Functional Language]
      {Implementing Equational Constraints\\
       in a Functional Language}
\frame{\titlepage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Functional Logic Languages}

\begin{block}{Goal: combine best of declarative paradigms in a single model}
\begin{itemize}%\expandlist{1ex}
\item {\blue efficient execution} principles of functional languages\\
(determinism, laziness)
\item {\blue flexibility} of logic languages\\
(computation with partial information, built-in search)
\item {\blue application-domains} of constraint languages\\
(constraint solvers for specific domains)
\item avoid non-declarative features
\end{itemize}
\end{block}
\vfill
\pause

\begin{block}{Curry {\lgrey [POPL'97,\ldots]} $\leadsto$ {\tt http://www.curry-language.org/}}
\begin{itemize}%\expandlist{1ex}
\item declarative multi-paradigm language\\
 (higher-order concurrent functional logic language)
\item extension of Haskell (non-strict functional language)
\end{itemize}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Curry Programs}

\begin{exampleblock}{Datatypes (values): enumerate all constructors}
\begin{prog}
 data Bool       = {\blue True}    | {\blue{}False}
 data List a     = {\blue []}      | a {\blue :} List a   {\red-- [a]}
\end{prog}
\end{exampleblock}
\vfill
\pause

\begin{block}{Program rules:~ $f~t_1\ldots t_n~|~c~=~r$}
\begin{tabular}{r@{~~:~~}l@{\qquad}r@{~~:~~}l}
$f$ & function name & $t_1\ldots t_n$ & data terms\\
$c$ & condition of type \code{Success} (optional) & $r$ & expression
\end{tabular}
\end{block}
\vfill

\begin{exampleblock}{Example \hspace{4cm}\only<3>{(with \alert{equational constraint}~ \texttt{=:=})}}
\begin{curry}
(++) :: [a] -> [a] -> [a]    $\only<3>{\code{last :: [a] -> a}}$
[]     ++ ys = ys              $\only<3>{\code{last xs | \alert{ys ++ [x] =:= xs}}}$
(x:xs) ++ ys = x : xs ++ ys             $\only<3>{\code{= x  where ys,x free}}$
\end{curry}
\end{exampleblock}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Non-deterministic Operations}

\begin{exampleblock}{Choice operation}
\vspace{-1ex}
\begin{curry}
 x ? _  =  x               aBool = True ? False
 _ ? y  =  y$\listline\pause$
not True  = False          xor True  x = not x
not False = True           xor False x = x$\listline$
xorSelf x = xor x x
\end{curry}
\end{exampleblock}
\pause

\begin{exampleblock}{Challenge: combining laziness and non-determinism}
\begin{curry}
 xorSelf aBool$\pause$  $\to~~$xor aBool aBool$\pause$    $\to~$  xor True aBool$\pause$
                $\to~~$xor True False$\pause$     $\to~$  not False$\pause$       $\to~$ True
\end{curry}
\end{exampleblock}
\pause

\begin{block}{Avoid unintended results: ``call-time choice''}
\begin{itemize}
\item semantics: arguments $\approx$ values (not non-deterministic operations!)
\item execution: keep laziness via \emph{sharing}
\item \alert{share/identify choices coming from same source}
\end{itemize}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Implementing Curry: KiCS2}

\begin{block}{Compiling to Haskell: {\bf KiCS2} {\lgrey[WFLP'11]}}
\begin{itemize}
\item reuse laziness, higher-order
\item implement non-determinism, logic variables
\item advantages: \alert{search strategy not fixed}\\
      (backtracking, breadth-first, iterative deepening, parallel,$\ldots$)
\end{itemize}
\end{block}
\pause
\begin{block}{Principles of KiCS2}
\begin{itemize}\expandlist{2ex}
\item represent search space as data ($\approx$ search tree)
\item defined operation: generate \emph{all} its values
\item search strategy $\approx$ search tree traversal
\item Haskell's laziness: no problem with infinite trees
\end{itemize}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Representing Non-deterministic Results}

\begin{block}{Every operation could have non-deterministic results!}
$\leadsto$ represent a choice between values as data:
\begin{curry}
data Bool = False | True $\pause$| Choice $\only<5->{\texttt{\alert{ID}}}$ Bool Bool | $~$Fail$\listline\pause$
aBool = True ? False $\leadsto$  aBool $\only<5->{\texttt{\alert{s}}}$ =$~$Choice $\only<5->{\texttt{\alert{(thisID s)}}}$ True False
\end{curry}
\pause
Missing: \alert{identify choices}\pause~~$\leadsto$~~add unique(!) identifier to each choice
\end{block}
\pause
\vfill
\begin{block}{Creation of choice identifiers}
\begin{itemize}
\item avoid side effects (to support optimization, parallel evaluation)
\item supply each operation with \alert{set of choice ids} (\code{IDSupply})
\item different operations get distinct subsets of choice ids
\end{itemize}
\end{block}
\vfill\pause

\begin{exampleblock}{Interface of {\tt IDSupply}}
\vspace{-1ex}
\begin{curry}
initSupply  :: IO IDSupply            $\only<7>{\alert{\mbox{\tt{-- create}}}}\only<8>{\alert{\mbox{\tt{initSupply = return 1}}}}$
thisID      :: IDSupply -> ID        $\only<7>{\alert{\mbox{\tt{-- get one id}}}}\only<8>{\alert{\mbox{\tt{thisID~~~~~ n = n}}}}$
leftSupply  :: IDSupply -> IDSupply  $\only<7>{\alert{\mbox{\tt{-- split into}}}}\only<8>{\alert{\mbox{\tt{leftSupply~ n = 2*n}}}}$
rightSupply :: IDSupply -> IDSupply  $\only<7>{\alert{\mbox{\tt{-- disjoint subsets}}}}\only<8>{\alert{\mbox{\tt{rightSupply n = 2*n+1}}}}$
\end{curry}
\end{exampleblock}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Compilation Scheme}

\begin{block}{Translate Curry programs into functional programs}
\begin{itemize}
\item every operation: additional \code{IDSupply} argument
\item supply each \code{Choice} with unique identifier
\item pattern matching: extended with cases for \code{Choice} and \code{Fail}
\end{itemize}
\end{block}
\pause
\vfill

\begin{exampleblock}{}
\begin{curry}
aBool :: Bool         $\leadsto$   aBool :: IDSupply -> Bool
aBool = True ? False  $\leadsto$   aBool s =$~$Choice (thisID s) True False
$\pause$
not :: Bool $\only<4->{\alert{\to~\mbox{\tt{IDSupply}}}}$ -> Bool
not True  $\only<4->{\alert{\mbox{\tt{s}}}}$ =$~$False
not False $\only<4->{\alert{\mbox{\tt{s}}}}$ =$~$True$\pause$
$\alert{\mbox{\tt{not (Choice i x1 x2) s = Choice i (not x1) (not x2)}}}$
$\alert{\mbox{\tt{not Fail s = Fail}}}\pause$

main :: $\only<6->{\alert{\mbox{\tt{IDSupply}}~\to}}$ Bool
main $\only<6->{\alert{\mbox{\tt{s}}}}$ =$~$xorSelf $\only<6->{\alert{\mbox{\tt{(}}}}$aBool $\only<6->{\alert{\mbox{\tt{(leftSupply s)) (rightSupply s)}}}}$
\end{curry}
\end{exampleblock}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Choices with Identifiers}

\begin{block}{Principle: each choice gets its own id}
\begin{curry}
xorSelf aBool $\pause\leadsto$
Choice 1 (Choice 1 False True) (Choice 1 True False)
\end{curry}
Interpretation: essentially one choice $\leadsto$ two solutions (\code{False}, \code{False})
\pause
\bigskip
\begin{curry}
xor aBool aBool $\pause\leadsto$
Choice 1 (Choice 2 False True) (Choice 2 True False)
\end{curry}
\medskip
Two different choices $\leadsto$ four solutions (\code{False}, \code{True}, \code{True}, \code{False})
\end{block}
\pause
\vfill

\begin{block}{Overall computation strategy}
\begin{itemize}\expandlist{0.5ex}
\item operations compute all non-deterministic results (as \code{Choice} structure)
\item top-level selects different values and prints them
\item top-level responsible for search strategy
\end{itemize}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Top Level: Print Results}

\begin{block}{Extract values from computed choice structure}
\begin{itemize}\expandlist{0.5ex}
\item make all possible selections (left, right for each \code{Choice})
\item make consistent selections (same choice for identified \code{Choice})
\end{itemize}
\pause
\begin{curry}
   xorSelf aBool
   $\leadsto$ Choice 1 (Choice 1 False True) (Choice 1 True False)
   $\pause\leadsto$   False   $\vee$   False
\end{curry}
\pause
\begin{itemize}\expandlist{0.5ex}
\item manage global structure (e.g., finite map) to store current selections
\item search strategy $\approx$ strategy to visit tree of choices
\end{itemize}
\end{block}
\vfill\pause

\begin{block}{Management of choice selections}
\begin{curry}
  data Decision = NoDecision | ChooseLeft | ChooseRight$\listline$
  lookupDecision :: ID -> IO Decision          $\alert{\mbox{\tt{-- retrieve}}}$
  setDecision    :: ID -> Decision -> IO ()   $\alert{\mbox{\tt{-- modify}}}$
\end{curry}
\end{block}
\end{frame}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}[fragile]
\frametitle{Logic Variables}
\vspace{-1ex}
\begin{block}{Kernel language supports choices but no logic variables}
\begin{itemize}
\item logic variables are replaced by non-deterministic generators
\item generator: evaluates to all possible values
\end{itemize}
\end{block}
\vfill
\pause

\begin{exampleblock}{}\vspace{-1ex}
\begin{curry}
-- Generator for Booleans
aBool :: Bool
aBool = True ? False$\listline$
-- Generator for list of Booleans
aBoolList :: [Bool]
aBoolList = [] ? (aBool : aBoolList)$\listline$
main = not x where x free   $\leadsto~~$  main =$~$not aBool
\end{curry}
\end{exampleblock}
\vfill
\pause

\begin{block}{}
\citebib{Antoy/Hanus ICLP'06}:\\[1ex]
narrowing (resolution) on logic variables \\
$~~~~~~~~~~~~~~~~~~~~~~~\Updownarrow$\\
non-deterministic rewriting with generators
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Logic Variables and Unification}

\begin{block}{Equational Constraints}
\begin{itemize}
\item generators instead of logic variables sufficient in principle
\item could be inefficient with constraints on partially known values
\end{itemize}
\end{block}
\vfill
\pause

\begin{exampleblock}{}
\code{xs},\code{ys} logic variables of type \code{[Bool]}:\\
\pause
\code{xs =:= [True]} $~\leadsto$ search space (instead of deterministic binding)\\
\pause
\code{xs =:= ys} \hspace{5.7ex}$\leadsto$ infinitely many solutions!
\end{exampleblock}
\vfill
\pause

\begin{block}{Unification}
\begin{itemize}
\item better: bind logic variables instead of enumerating identical values
\item necessary extensions:
\begin{itemize}
\item mark unevaluated generators ($\approx$ unbound variables)
\item add binding constraints to values
\end{itemize}
\end{itemize}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Implementing Equational Constraints}

\begin{block}{Representation of logic variables}
\begin{curry}
data ID = ChoiceID Integer | $\alert{\mbox{\tt{FreeID}}}$ Integer$\listline$
aBool s = Choice ($\alert{\mbox{\tt{FreeID}}}$ (thisID s)) True False
\end{curry}
\end{block}
\vfill
\pause

\begin{block}{Add binding constraints to values}
\begin{curry}
data Constraint = ID :=: Decision$\listline$
data Bool   = $\ldots$ |$~$Guard [Constraint] Bool
data List a = $\ldots$ |$~$Guard [Constraint] (List a)
\end{curry}
\pause
\medskip
Implementation of equational constraints:
\begin{curry}
Choice (FreeID i) _ _ =:= True  = Guard$\,$[i:=:ChooseLeft ]$\,$Success
Choice (FreeID i) _ _ =:= False = Guard$\,$[i:=:ChooseRight]$\,$Success
$\ldots$
\end{curry}
\medskip
Binding constraints are processed/checked by top-level printing
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Functional Patterns {\lgrey\small[Antoy/H. LOPSTR'05]}}

\begin{block}{Useful extension: allow defined functions in patterns}
\begin{curry}
last (xs++[x]) = x
\end{curry}
\end{block}
\vfill
\pause

\begin{block}{Semantics: abbreviates all values of functional pattern}
\begin{curry}
last [x] = x              -- xs$\mapsto$[]
last [x1,x] = x           -- xs$\mapsto$[x1]
last [x1,x2,x] = x        -- xs$\mapsto$[x1,x2]
$\ldots$
\end{curry}
\end{block}
\vfill
\pause

\begin{block}{Implementation: lazy unification ``{\tt{=:<=}}''}
\begin{curry}
last ys | (xs++[x]) =:<= ys  = x   where xs, x free
\end{curry}
\medskip
Difference to ``{\tt{=:=}}'': bind variable to \emph{unevaluated} expression\\
\code{last [failed,True] $\leadsto$ True}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Implementing Lazy Unification}

\begin{block}{Add lazy binding constraints as decisions}
\begin{curry}
data Decision = $\ldots$ |$~$LazyBind [Constraint]
\end{curry}
\end{block}
\vfill
\pause

\begin{block}{Lazy unification with variables: add lazy binding constraints}
\begin{curry}
Choice (FreeID i) _ _ =:<= x
    = Guard [i :=: LazyBind (lazyBind i x)] Success$\listline$
lazyBind :: ID -> a -> [Constraint]
lazyBind i True  = [i :=: ChooseLeft]
lazyBind i False = [i :=: ChooseRight]
\end{curry}
\medskip
$\leadsto$ these constraints are evaluated when value is demanded
\end{block}
\vfill
\pause

\begin{exampleblock}{}
\begin{curry}
xs++[x] =:<= [failed,True]
$\leadsto$ Guard [ 4 :=: LazyBind (lazyBind 4 failed),
           3 :=: LazyBind (lazyBind 3 True)] Success
\end{curry}
\end{exampleblock}
\end{frame}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Benchmarks}

\begin{block}{Comparing different representations for equations in KiCS2}
\begin{center}
\begin{tabular}{|l|r|r|r|}
\hline
Expression                              & \code{==~}& \code{=:=}& \code{=:<=} \\
\hline
\code{last (map (inc 0) [1..10000])}   &  2.91   &    0.05   &    0.01   \\
\code{simplify}                         & 10.30      & 6.77      & 7.07        \\
\code{varInExp}                         & 2.34    & 0.24      & 0.21        \\
\code{fromPeano (half (toPeano 10000))} & 26.67     & 5.95      & 11.19       \\
\code{palindrome}                       & 30.86     & 14.05     & 20.26       \\
\code{horseman}                         & 3.24      & 3.31      & n/a         \\
\code{grep}                             & 1.06      & 0.10      & n/a         \\
\hline
\end{tabular}
\end{center}
\end{block}
\vfill

\begin{block}{}
\begin{description}
\item[\code{==}~:] Boolean equality without variable bindings
\item[\code{=:=}~:] equational constraint with variable bindings
\item[\code{=:<=}~:] lazy unification with unevaluated variable bindings
\end{description}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}
\frametitle{Conclusions}
\vspace{-1ex}
\begin{block}{}
\begin{itemize}
\item novel implementation techniques for equational constraints
\item add binding constraints to computed values
\item process them when extracting values from search space
\item only new constructors added, no overhead for existing implementation
\item more efficient execution if features are used
\end{itemize}
\end{block}
\vfill
\begin{block}{Advantages of KiCS2}
\begin{itemize}
\item highly efficient for deterministic parts, competitive for non-det. programs
\item flexible search strategies
\item many opportunities for optimizations (determinism analysis)
\item exploit future improvements of Haskell implementations
\end{itemize}
\end{block}
\vfill
\begin{block}{Future Work}
\begin{itemize}
\item Add further constraint structures
\end{itemize}
\end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Benchmarks {\lgrey [WFLP'11]}}

\begin{block}{Deterministic Programs}
\begin{center}
\begin{tabular}{|@{~~}l@{~~}|l@{~~}|*{4}{@{~~}r@{~~}|}}
\hline
System  & Target   & ReverseUser & Reverse &  Tak  & TakPeano \\\hline
KiCS2   & Haskell  &      0.12   &   0.12  &  0.21 &    0.79  \\[0.5ex]
PAKCS   & SICStus-Prolog    &      2.05   &   1.88  & 39.80 &   62.43  \\[0.5ex]
MCC     & VM/C     &      0.43   &   0.47  &  1.21 &    5.49  \\[0.5ex]
\hline
\end{tabular}
\end{center}
\end{block}
\vfill

\begin{block}{Non-deterministic Programs}
\begin{center}
\begin{tabular}{|@{~~}l@{~~}|*{4}{@{~~}r@{~~}|}}
\hline
System  & PermSort & PermSortPeano &  Last & RegExp \\\hline
KiCS2   &    2.83  &        3.68   &  0.14 &   0.49 \\[0.5ex]
PAKCS   &   26.96  &       67.11   &  2.61 &  12.70 \\[0.5ex]
MCC     &    1.46  &        5.74   &  0.09 &   0.57 \\[0.5ex]
\hline
\end{tabular}
\end{center}
\end{block}
\vfill
\begin{block}{}
  \begin{itemize}
  \item faster than Prolog-based implementations (PAKCS)
  \item competitive with VM/C-based implementation (MCC)
  \end{itemize}
\end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Benchmarks}

\begin{block}{Equational constraints}
\begin{center}
\begin{tabular}{|l|r|r|r|}
\hline
Expression                              & KiCS2 & PAKCS  & MCC  \\
\hline
\code{last (map (inc 0) [1..10000])}   & 0.05  & 0.40   &  0.01\\
\code{simplify}                         & 6.77  & 0.15   & 0.00 \\
\code{varInExp}                         & 0.24  & 0.89   & 0.07 \\
\code{fromPeano (half (toPeano 10000))} & 5.95  & 108.88 & 3.22 \\
\code{palindrome}                       & 14.05 & 32.56  & 1.07 \\
\code{horseman}                         & 3.31  & 8.70   & 0.42 \\
\code{grep}                             & 0.10  & 2.88   & 0.14 \\
\hline
\end{tabular}
\end{center}
\end{block}
\vfill
\begin{block}{}
  \begin{itemize}
  \item faster than Prolog-based implementations (PAKCS)
  \item primitive VM/C-based implementation (MCC) performs best
  \item with some exceptions ($\leadsto$ further investigations required)
  \end{itemize}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Benchmarks}

\begin{block}{Functional patterns}
\begin{center}
\begin{tabular}{|l|r|r|}
\hline
Expression                              & KiCS2 & PAKCS    \\
\hline
\code{last (map (inc 0) [1..10000])}   &  0.01 & 0.33     \\
\code{simplify}                         & 7.07  & 0.27     \\
\code{varInExp}                         &  0.21  &  1.87    \\
\code{fromPeano (half (toPeano 10000))} & 11.19 & $\infty$ \\
\code{palindrome}                       & 20.26 & $\infty$ \\
\hline
\end{tabular}
\end{center}
\end{block}
\vfill
\begin{block}{}
  \begin{itemize}
  \item currently only supported by PAKCS and KiCS2
  \item in many cases bettern than Prolog-based implementation
  \end{itemize}
\end{block}
\end{frame}

\end{document}

% LocalWords:  non-deterministic
