\section{Recognized Syntax of Curry}

The \CYS Curry compiler accepts a slightly extended version
of the grammar specified in the Curry Report \cite{Hanus12Curry}.
Furthermore, the syntax recognized by \CYS differs from that
specified in the Curry Report
regarding numeric or character literals.
We therefore present the complete description of the syntax below,
whereas syntactic \extension{extensions} are highlighted.

\subsection{Notational Conventions}

The syntax is given in extended Backus-Naur-Form (eBNF)
using the following notation:

\begin{table}[hbtp]
\begin{tabular}{rl}
\production{NonTerm}{$\alpha$} & production               \\
\nonterm{NonTerm}              & nonterminal symbol       \\
\term{Term}                    & terminal symbol          \\
\opt{$\alpha$}                 & optional                 \\
\many{$\alpha$}                & zero or more repetitions \\
\group{$\alpha$}               & grouping                 \\
$\alpha$ \sor $\beta$          & alternative              \\
\without{\alpha}{\beta}        & difference -- elements generated by $\alpha$ \\
                               & without those generated by $\beta$ \\
\end{tabular}
\end{table}

The Curry files are expected to be encoded in UTF8. However, source programs
are biased towards ASCII for compatibility reasons.

\subsection{Lexicon}

\subsubsection{Case Mode}

Although the Curry Report specifies four different case modes
(Prolog, G\"odel, Haskell, free),
the \CYS only supports the \emph{free} mode which puts no constraints
on the case of identifiers.

\subsubsection{Identifiers and Keywords}

\begin{grammar}
\production{Ident}{%
  \nonterm{Letter}
  \many{%
    \nonterm{Letter} \sor \nonterm{Digit} \sor \term{\us} \sor \term{'}
  }
}

\production{Letter}{\textrm{any ASCII letter}}

\production{Symbol}{%
  \term{\~} \sor \term{!}      \sor \term{@}  \sor \term{\#}  \sor \term{\$} \sor
  \term{\%} \sor \term{\caret} \sor \term{\&} \sor \term{*}   \sor \term{+}  \sor
  \term{-}  \sor \term{=}      \sor \term{<}  \sor \term{>}   \sor \term{?}  \sor
  \term{.}  \sor \term{/}      \sor \term{|}  \sor \term{\bs} \sor \term{:}
}

\production{ModuleID}{\many{\nonterm{Ident} \term{.}} \nonterm{Ident}}

\production{TypeConstrID}{\nonterm{Ident}}

\production{DataConstrID}{\nonterm{Ident}}

\production{TypeVarID}{\nonterm{Ident}}

\production{InfixOpID}{\nonterm{Symbol} \many{\nonterm{Symbol}}}

\production{FunctionID}{\nonterm{Ident}}

\production{VariableID}{\nonterm{Ident}}

\extension{
\production{LabelID}{\nonterm{Ident}}
}

\production{QTypeConstrID}{%
  \opt{\nonterm{ModuleID} \term{.}} \nonterm{TypeConstrID}
}

\production{QDataConstrID}{%
  \opt{\nonterm{ModuleID} \term{.}} \nonterm{DataConstrID}
}

\production{QInfixOpID}{%
  \opt{\nonterm{ModuleID} \term{.}} \nonterm{InfixOpID}
}

\production{QFunctionID}{%
  \opt{\nonterm{ModuleID} \term{.}} \nonterm{FunctionID}
}

\production{QVariableID}{%
  \opt{\nonterm{ModuleID} \term{.}} \nonterm{VariableID}
}

\extension{
\production{QLabelID}{%
\opt{\nonterm{ModuleID} \term{.}} \nonterm{VariableID}
}
}
\end{grammar}

The following identifiers are recognized as keywords
and cannot be used as an identifier:
\begin{curry}
case      data      do        else      external  fcase     foreign
free      if        import    in        infix     infixl    infixr
let       module    newtype   of        then      type      where
\end{curry}
% class instance deriving

Note that the symbols \term{as}, \term{hiding}
and \term{qualified} are not keywords.
They have only a special meaning in module headers
and can be used as ordinary identifiers.

The following symbols also have a special meaning and cannot
be used as an infix operator identifier:
\begin{curry}
..    :     ::    =     \\     |     <-    ->    @     ~     =>
\end{curry}

\subsubsection{Comments}

Comments begin either with ``\term{--}'' and terminate at the end of the line
or with ``\verb|{-|'' and terminate with a matching ``\verb|-}|'', i.e.,
the delimiters ``\verb|{-|'' and ``\verb|-}|''
act as parentheses and can be nested.

\subsubsection{Numeric and Character Literals}

Contrasting to the Curry Report, \CYS adopts Haskell's notation of literals,
for both numeric literals as well as \code{Char} and \code{String} literals.
The precise syntax for both kinds is given below.

\begin{grammar}
\production{Int}{%
  \nonterm{Decimal}
  \alt \term{0o} \nonterm{Octal}       \sor \term{0O} \nonterm{Octal}
  \alt \term{0x} \nonterm{Hexadecimal} \sor \term{0X} \nonterm{Hexadecimal}
}

\production{Float}{%
  \nonterm{Decimal} \term{.} \nonterm{Decimal} \opt{\nonterm{Exponent}}
  \alt \nonterm{Decimal} \nonterm{Exponent}
}

\production{Exponent}{%
  \group{\term{e}\sor\term{E}} \opt{\term{+} \sor \term{-}} \nonterm{Decimal}
}

\production{Decimal}{%
  Digit \opt{\nonterm{Decimal}}
}

\production{Octal}{%
  Octit \opt{\nonterm{Octal}}
}

\production{Hexadecimal}{%
  Hexit \opt{\nonterm{Hexadecimal}}
}

\production{Digit}{%
 \term{0} \sor \term{1} \sor \term{2} \sor \term{3} \sor \term{4} \sor
 \term{5} \sor \term{6} \sor \term{7} \sor \term{8} \sor \term{9}
}

\production{Octit}{%
 \term{0} \sor \term{1} \sor \term{2} \sor \term{3} \sor \term{4} \sor
 \term{5} \sor \term{6} \sor \term{7}
}

\production{Hexit}{%
 \term{0} \sor \term{1} \sor \term{2} \sor \term{3} \sor \term{4} \sor
 \term{5} \sor \term{6} \sor \term{7} \sor \term{8} \sor \term{9} \sor
 \term{A} \sor \term{B} \sor \term{C} \sor \term{D} \sor \term{E} \sor \term{F}
}
\end{grammar}

\begin{grammar}
\production{Char}{%
  \term{'}
  \group{%
    \without{Graphic}{\term{'}\sor\term{\bs}}
    \sor Space
    \sor \without{Escape}{\term{{\tt \bs \&}}}
  }
  \term{'}
}

\production{String}{%
  \term{"}
  \many{%
    \without{Graphic}{\term{"}\sor\term{\bs}}
    \sor Space
    \sor Escape
    \sor Gap
  }
  \term{"}
}

\production{Escape}{%
  \term{\bs}
  \group{%
    CharEsc \sor Ascii \sor \nonterm{Decimal}
    \sor \term{o} \nonterm{Octal} \sor \term{x} Hexadecimal
  }
}

\production{CharEsc}{%
  \term{a} \sor \term{b} \sor \term{f} \sor \term{n} \sor \term{r} \sor \term{t}
  \sor \term{v} \sor \term{\bs} \sor \term{"} \sor \term{'} \sor \term{\&}
}

\production{Ascii}{%
  \term{\caret} Cntrl \sor \term{NUL} \sor \term{SOH} \sor \term{STX} \sor \term{ETX}
  \sor \term{EOT}     \sor \term{ENQ} \sor \term{ACK}
  \alt \term{BEL}     \sor \term{BS}  \sor \term{HT}  \sor \term{LF}  \sor \term{VT}
  \sor \term{FF}      \sor \term{CR}  \sor \term{SO}  \sor \term{SI}  \sor \term{DLE}
  \alt \term{DC1}     \sor \term{DC2} \sor \term{DC3} \sor \term{DC4} \sor \term{NAK}
  \sor \term{SYN}     \sor \term{ETB} \sor \term{CAN}
  \alt \term{EM}      \sor \term{SUB} \sor \term{ESC} \sor \term{FS}  \sor \term{GS}
  \sor \term{RS}      \sor \term{US}  \sor \term{SP}  \sor \term{DEL}
}

\production{Cntrl}{%
  AsciiLarge \sor \term{@} \sor \term{[} \sor \term{\bs} \sor \term{]}
  \sor \term{\caret} \sor \term{\us}
}

\production{AsciiLarge}{%
  \term{A} \sor $\ldots$ \sor \term{Z}
}

\production{Gap}{%
  \term{\bs} WhiteChar \many{WhiteChar} \term{\bs}
}
\end{grammar}

\subsection{Layout}
Similarly to Haskell, a Curry programmer can use layout information
to define the structure of blocks. For this purpose, we define
the indentation of a symbol as the column number indicating
the start of this symbol. The indentation of a line is the
indentation of its first symbol.\footnote{In order to determine
the exact column number, we assume a fixed-width font with
tab stops at each 8th column.}

The layout (or ``off-side'') rule applies to lists of syntactic
entities after the keywords \term{let}\pindex{let},
\term{where}\pindex{where}, \term{do}\pindex{do}, or \code{of}\pindex{of}.
In the subsequent context-free syntax,
these lists are enclosed with
curly brackets (\term{\{ \}}) and the single entities are
separated by semicolons (\term{;}). Instead of using the curly
brackets and semicolons of the context-free syntax,
a Curry programmer must specify these lists
by indentation: the indentation of a list of syntactic
entities after \term{let}, \term{where}, \code{do}, or \code{of} is the
indentation of the next symbol following the
\term{let}, \term{where}, \code{do}, \code{of}. Any item of this list
start with the same indentation as the list. Lines with only whitespaces or
an indentation greater than the indentation of the list continue
the item in its previous line. Lines with an indentation less than
the indentation of the list terminates the entire list.
Moreover, a list started by \term{let} is terminated by the
keyword \code{in}. Thus, the sentence
\begin{curry}
f x = h x where \{ g y = y + 1 ; h z = (g z) * 2 \}
\end{curry}
which is valid w.r.t.\ the context-free syntax, is written
with the layout rules as
\begin{curry}
f x = h x
 where g y = y + 1
       h z = (g z) * 2
\end{curry}
or also as
\begin{curry}
f x = h x  where
  g y = y + 1
  h z = (g z)
          * 2
\end{curry}
To avoid an indentation of top-level declarations,
the keyword \term{module} and the end-of-file token are
assumed to start in column 0.

\subsection{Context Free Grammar}

\begin{grammar}
\production{Module}{%
  \term{module} ModuleID \opt{Exports} \term{where} Block
  \extension{\alt Block}
}

\lexicon{ModuleID}

\production{Exports}{%
  \term{(} \seq{Export}{,}{n} \term{)} \extension{\margin{n \geqslant 0}}
}

\production{Export}{%
  QFunctionName
  \alt QTypeConstrID
  \extension{\opt{\term{(} \seq{DataConstrID}{,}{n} \term{)}} \margin{n \geqslant 0}}
  \alt QTypeConstrID \term{(..)}
  \alt \term{module} ModuleID
}

\production{Block}{%
  \term{\{}
  \opt{\seq{ImportDecl}{;}{k} \term{;}}
  \extension{\nextline \margtext{no fixity declarations}}
  \nextline \phantom{\term{\{}}
  \seq{BlockDeclaration}{;}{n}
  \term{\}}
  \margin{k,n \geqslant 0}
}

\production{ImportDecl}{%
  \term{import} \opt{\term{qualified}} ModuleID \opt{\term{as} ModuleID}
                \opt{ImportRestr}
}

\production{ImportRestr}{%
  \term{(} \seq{Import}{,}{n} \term{)}
  \extension{\margin{n \geqslant 0}}
  \alt \term{hiding} \term{(} \seq{Import}{,}{n} \term{)}
  \extension{\margin{n \geqslant 0}}
}

\production{Import}{%
  FunctionName
  \alt TypeConstrID
  \extension{\opt{\term{(} \seq{DataConstrID}{,}{n} \term{)}} \margin{n \geqslant 0}}
  \alt TypeConstrID \term{(..)}
}

\production{BlockDeclaration}{%
  TypeSynonymDecl
  \alt DataDeclaration
  \extension{\alt FixityDeclaration}
  \alt FunctionDeclaration
}

\production{TypeSynonymDecl}{%
  \term{type} SimpleType \term{=} TypeExpr
  \extension{\alt \term{type} SimpleType \term{=} RecordType}
}

\production{SimpleType}{%
  TypeConstrID \seq{TypeVarID}{}{n} \margin{n \geqslant 0}
}

\lexicon{TypeConstrID}

\production{DataDeclaration}{%
  \term{data} SimpleType \term{=} \seq{ConstrDecl}{|}{n} \margin{n > 0}
}

\production{ConstrDecl}{%
  DataConstrID \seq{SimpleTypeExpr}{}{n} \margin{n \geqslant 0}
}

\lexicon{DataConstrID}

\extension{
\production{RecordType}{%
  \term{\{} \seq{LabelDecl}{,}{n} \term{\}} \margin{n > 0}
}

\production{LabelDecl}{%
  \seq{LabelID}{,}{n} \term{::} TypeExpr \margin{n > 0}
}

\lexicon{LabelID}
}

\production{TypeExpr}{%
  SimpleTypeExpr \opt{\term{->} TypeExpr}
}

\production{SimpleTypeExpr}{%
  QTypeConstrID \seq{SimpleTypeExpr}{}{n} \margin{n \geqslant 0}
  \alt TypeVarID
  \alt \term{\us}
  \alt \term{()} \margin{\mbox{\it unit type}}
  \alt \term{(} \seq{TypeExpr}{,}{n} \term{)} \margcomb{tuple type}{n>1}
  \alt \term{[} TypeExpr \term{]} \margtext{list type}
  \alt \term{(} TypeExpr \term{)} \margtext{parenthesized type}
}

\lexicon{TypeVarID}

\production{FixityDeclaration}{%
  FixityKeyword Digit \seq{InfixOpID}{,}{n} \margin{n>0}
}

\production{FixityKeyword}{%
  \term{infixl} \sor \term{infixr} \sor \term{infix}
}

\lexicon{InfixOpID}

\production{FunctionDeclaration}{%
  Signature \sor Equat
}

\production{Signature}{%
  FunctionNames \term{::} TypeExpr
}

\production{FunctionNames}{%
  \seq{FunctionName}{,}{n} \margin{n>0}
}

\production{FunctionName}{%
  \term{(} InfixOpID \term{)}
  \alt FunctionID
}

\lexicon{FunctionID}

\production{Equat}{%
  FunLHS \term{=} \extension{TypedExpr} \opt{\term{where} LocalDefs}
  \alt FunLHS CondExprs \opt{\term{where} LocalDefs}
  \extension{\alt FunLHS \term{external} \margtext{externally defined function}}
}

\production{FunLHS}{%
  FunctionName \seq{SimplePat}{}{n} \margin{n \geqslant 0}
  \alt SimplePat InfixOpID SimplePat
}

\production{Pattern}{%
  QDataConstrID \seq{SimplePat}{}{n} \opt{\term{:} Pattern} \margin{n > 0}
  \alt SimplePat \opt{\term{:} Pattern}
}

\production{SimplePat}{%
  VariableID
  \alt \term{\us}
  \alt QDataConstrID
  \alt Literal
  \alt \term{()}
  \alt \term{(} \seq{Pattern}{,}{n} \term{)}
       \margin{n > 1}
%  \alt \term{(} QDataConstrID \seq{Pattern}{}{n} \term{)} \margin{n > 0}
  \alt \term{(} Pattern \term{)}
       \extension{\margtext{parenthesized pattern}}
  \alt \term{[} \seq{Pattern}{,}{n} \term{]}
       \margin{n \geqslant 0}
  \alt VariableID \term{@} SimplePat
       \margtext{as-pattern}
\extension{
  \alt \term{\~{}} SimplePat
       \margtext{lazy pattern}
  \alt \term{(} SimplePat QOpName SimplePat \term{)}
       \margtext{infix functional pattern}
  \alt \term{(} QFunctionName \seq{SimplePat}{}{n} \term{)}
       \margcomb{functional pattern}{n > 0}
  \alt \term{\{} \seq{LabelPat}{,}{n} \opt{\term{| _}} \term{\}}
       \margtext{Record Pattern}
}
}

\extension{
\production{LabelPat}{%
  LabelID \term = Pattern
}
}

\lexicon{VariableID}

\production{LocalDefs}{%
  \offside{ValueDeclaration}{;}{n} \margin{n > 0}
}

\production{ValueDeclaration}{%
  FunctionDeclaration
  \alt PatternDeclaration
  \alt \seq{VariableID}{,}{n} \term{free} \margin{n > 0}
}

\production{PatternDeclaration}{%
  Pattern \term{=} TypedExpr \opt{\term{where} LocalDefs}
}

\production{CondExprs}{%
  \term{|} \extension{TypedExpr} \term{=} \extension{TypedExpr} \opt{CondExprs}
}

\extension{
\production{TypedExpr}{%
  InfixExpr \term{::} TypeExpr \margtext{expression type signature}
  \alt InfixExpr
}

\production{InfixExpr}{%
  Expr QOpName InfixExpr \margtext{infix operator application}
  \alt \term{-} InfixExpr   \margtext{unary int minus}
  \alt \term{-.} InfixExpr  \margtext{unary float minus}
}
}

\production{Expr}{%
       \term{\bs} \seq{SimplePat}{}{n} \term{->} Expr
       \margcomb{lambda expression}{n > 0}
  \alt \term{let} LocalDefs \term{in} Expr
       \margtext{let expression}
  \alt \term{if} Expr \term{then} Expr \term{else} Expr
       \margtext{conditional}
  \alt \term{case} Expr \term{of} \offside{Alt}{;}{n}
       \margcomb{case expression}{n \geqslant 0}
  \alt \term{fcase} Expr \term{of} \offside{Alt}{;}{n}
       \margcomb{fcase expression}{n \geqslant 0}
  \alt \term{do} \term{\{} \seq{Stmt}{;}{n} \term{;} Expr \term{\}}
       \margcomb{do expression}{n \geqslant 0}
  \alt FunctExpr
}

\production{FunctExpr}{%
       \opt{FunctExpr} BasicExpr   \margtext{function application}
\extension{
  \alt FunctExpr \term{:>} LabelID \margtext{record selection}
}
}

\production{BasicExpr}{%
       QVariableID
       \margtext{variable}
  \alt \term{\us}
       \margtext{anonymous free variable}
  \alt QDataConstrID
       \margtext{data constructor}
  \alt QFunctionID
       \margtext{defined function}
  \alt \term{(} QInfixOpID \term{)}
       \margtext{operator function}
  \alt Literal
  \alt \term{()}
       \margtext{empty tuple}
  \alt \term{(} Expr \term{)}
       \margtext{parenthesized expression}
  \alt \term{(} \seq{Expr}{,}{n} \term{)}
       \margcomb{tuple}{n > 1}
  \alt \term{[} \seq{Expr}{,}{n} \term{]}
       \margcomb{finite list}{n\geqslant 0}
  \alt \term{[} Expr \opt{\term{,} Expr} \term{..} \opt{Expr} \term{]}
       \margtext{arithmetic sequence}
  \alt \term{[} Expr \term{|} \seq{Qual}{,}{n} \term{]}
       \margcomb{list comprehension}{n\geqslant 1}
  \alt \term{(} Expr \extension{QOpName} \term{)}
       \margtext{left section}
  \alt \term{(} \extension{QOpName} Expr \term{)}
       \margtext{right section}
\extension{
  \alt \term{\{} \seq{LBind}{,}{n} \term{\}}
       \margcomb{labeled construction}{n > 0}
  \alt \term{\{} \seq{LBind}{,}{n} \term{|} Expr \term{\}}
       \margcomb{labeled update}{n > 0}
  }
}

\production{LBind}{%
  LabelID \term{:=} \extension{TypedExpr}
}

\production{Alt}{%
       Pattern \term{->} \extension{TypedExpr} \opt{\term{where} LocalDefs}
  \alt Pattern GdAlts                          \opt{\term{where} LocalDefs}
}

\production{GdAlts}{%
  \term{|} \extension{TypedExpr} \term{->} \extension{TypedExpr} \opt{GdAlts}
}

\production{Qual}{%
       \extension{TypedExpr}
  \alt \term{let} LocalDefs
  \alt Pattern \term{<-} \extension{TypedExpr}
}

\production{Stmt}{%
       \extension{TypedExpr}
  \alt \term{let} LocalDefs
  \alt Pattern \term{<-} \extension{TypedExpr}
}

\production{Literal}{%
  Int \sor Char \sor String \sor Float
}

\production{QFunctionName}{%
  \term{(} QInfixOpID \term{)} \sor QFunctionID
}

\extension{
\production{QOpName}{%
  QInfixOpID \sor \term{`} QFunctionID \term{`}
}
}
\end{grammar}