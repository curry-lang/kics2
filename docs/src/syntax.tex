\section{Recognized Syntax of Curry}

The \CYS Curry compiler accepts a slightly extended version
of the grammar specified in the Curry Report \cite{Hanus15Curry}.
Furthermore, the syntax recognized by \CYS differs
from that specified in the Curry Report
regarding numeric or character literals.
We therefore present the complete description of the syntax below,
whereas \extension{syntactic extensions} are highlighted.

\subsection{Notational Conventions}

The syntax is given in extended Backus-Naur-Form (eBNF),
using the following notation:

\begin{table}[hbtp]
\begin{tabular}{rl}
\trim{\removelinebreaks{%
\production{NonTerm}{$\alpha$}}} & production               \\
\nonterm{NonTerm}                & nonterminal symbol       \\
\term{Term}                      & terminal symbol          \\
\opt{$\alpha$}                   & optional                 \\
\many{$\alpha$}                  & zero or more repetitions \\
\group{$\alpha$}                 & grouping                 \\
$\alpha$ \sor $\beta$            & alternative              \\
\without{\alpha}{\beta}          & difference -- elements generated by $\alpha$\\
                                 & without those generated by $\beta$ \\
\end{tabular}
\end{table}

The Curry files are expected to be encoded in UTF8.
However, source programs are biased towards ASCII for compatibility reasons.

\subsection{Lexicon}

\subsubsection{Case Mode}

Although the Curry Report specifies four different case modes
(Prolog, G\"odel, Haskell, free),
the \CYS only supports the \emph{free} mode
which puts no constraints on the case of identifiers.

\subsubsection{Identifiers and Keywords}

\begin{grammar}
\production{Letter}{\text{any ASCII letter}}
\production{Dashes}{\term{--} \many{\term{-}}}

% Ident and Symbol
\production{Ident}{
  Letter \many{Letter \sor Digit \sor \term{\us} \sor \term{'}}
}
\production{Symbol}{
  \term{\~} \sor \term{!}      \sor \term{@}  \sor \term{\#}  \sor \term{\$} \sor
  \term{\%} \sor \term{\caret} \sor \term{\&} \sor \term{*}   \sor \term{+}  \sor
  \term{-}  \sor \term{=}      \sor \term{<}  \sor \term{>}   \sor \term{?}  \sor
  \term{.}  \sor \term{/}      \sor \term{|}  \sor \term{\bs} \sor \term{:}
}

% Identifiers
\production{ModuleID    }{\many{Ident \term{.}} Ident}
\production{TypeConstrID}{Ident}
\production{DataConstrID}{Ident}
\production{TypeVarID   }{Ident \extension{\sor \term{\us}}}
\production{InfixOpID   }{\without{\group{Symbol~\many{Symbol}}}{Dashes}}
\production{FunctionID  }{Ident}
\production{VariableID  }{Ident}
\production{LabelID     }{Ident}

\production{QTypeConstrID}{\opt{ModuleID \term{.}} TypeConstrID}
\production{QDataConstrID}{\opt{ModuleID \term{.}} DataConstrID}
\production{QInfixOpID   }{\opt{ModuleID \term{.}} InfixOpID   }
\production{QFunctionID  }{\opt{ModuleID \term{.}} FunctionID  }
\production{QVariableID  }{\opt{ModuleID \term{.}} VariableID  }
\production{QLabelID     }{\opt{ModuleID \term{.}} LabelID     }
\end{grammar}

The following identifiers are recognized as keywords
and cannot be used as an identifier:
\begin{lstlisting}[escapechar=']
case      data      do        else      external  fcase     '\extension{foreign}'
free      if        import    in        infix     infixl    infixr
let       module    '\extension{newtype}'   of        then      type      where
\end{lstlisting}
% class instance deriving

Note that the symbols \term{as}, \term{hiding}
and \term{qualified} are not keywords.
They have only a special meaning in module headers
and can be used as ordinary identifiers.

The following symbols also have a special meaning and cannot
be used as an infix operator identifier:
\begin{lstlisting}[escapechar=',literate=]
..    :     ::    =     \     |     <-    ->    @     ~
\end{lstlisting}

\subsubsection{Comments}

Comments begin either with ``\term{--}'' and terminate at the end of the line
or with ``\verb|{-|'' and terminate with a matching ``\verb|-}|'', i.e.,
the delimiters ``\verb|{-|'' and ``\verb|-}|''
act as parentheses and can be nested.

\subsubsection{Numeric and Character Literals}

Contrasting to the Curry Report, \CYS adopts Haskell's notation of literals,
for both numeric literals as well as \code{Char} and \code{String} literals.
The precise syntax for both kinds is given below.

\begin{grammar}
\production{Int}{
       Decimal
\extension{
  \alt \term{0b} Binary      \sor \term{0B} Binary
}
  \alt \term{0o} Octal       \sor \term{0O} Octal
  \alt \term{0x} Hexadecimal \sor \term{0X} Hexadecimal
}

\production{Float}{
       Decimal \term{.} Decimal \opt{Exponent}
  \alt Decimal Exponent
}
\production{Exponent}{
  \group{\term{e} \sor \term{E}} \opt{\term{+} \sor \term{-}} Decimal
}

\production{Decimal    }{Digit \opt{Decimal}    }
\extension{
\production{Binary     }{Binit \opt{Binary}     }
}%
\production{Octal      }{Octit \opt{Octal}      }
\production{Hexadecimal}{Hexit \opt{Hexadecimal}}

\production{Digit}{
 \term{0} \sor \term{1} \sor \term{2} \sor \term{3} \sor \term{4} \sor
 \term{5} \sor \term{6} \sor \term{7} \sor \term{8} \sor \term{9}
}
\extension{
\production{Binit}{\term{0} \sor \term{1}}
}%
\production{Octit}{
 \term{0} \sor \term{1} \sor \term{2} \sor \term{3} \sor \term{4} \sor
 \term{5} \sor \term{6} \sor \term{7}
}
\production{Hexit}{
 \term{0} \sor \term{1} \sor \term{2} \sor \term{3} \sor \term{4} \sor
 \term{5} \sor \term{6} \sor \term{7} \sor \term{8} \sor \term{9} \sor
 \term{A} \sor \term{B} \sor \term{C} \sor \term{D} \sor \term{E} \sor
 \term{F} \sor \term{a} \sor \term{b} \sor \term{c} \sor \term{d} \sor
 \term{e} \sor \term{f}
}

\production{Char}{
  \term{'}%
  \group{
    \without{\nonterm{Graphic}}{\term{\bs}}
    \sor Space
    \sor \without{\nonterm{Escape}}{\term{{\tt \bs \&}}}
  }%
  \term{'}
}
\production{String}{
  \term{"}%
  \many{
    \without{\nonterm{Graphic}}{\term{"} \sor \term{\bs}}
    \sor Space
    \sor Escape
    \sor Gap
  }%
  \term{"}
}
\production{Escape}{
  \term{\bs}
  \group{
    CharEsc \sor Ascii \sor Decimal
    \sor \term{o} Octal \sor \term{x} Hexadecimal
  }
}
\production{CharEsc}{
  \term{a} \sor \term{b} \sor \term{f} \sor \term{n} \sor \term{r} \sor \term{t}
  \sor \term{v} \sor \term{\bs} \sor \term{"} \sor \term{'} \sor \term{\&}
}
\production{Ascii}{
  \term{\caret} Cntrl \sor \term{NUL} \sor \term{SOH} \sor \term{STX} \sor \term{ETX}
  \sor \term{EOT}     \sor \term{ENQ} \sor \term{ACK}
  \alt \term{BEL}     \sor \term{BS}  \sor \term{HT}  \sor \term{LF}  \sor \term{VT}
  \sor \term{FF}      \sor \term{CR}  \sor \term{SO}  \sor \term{SI}  \sor \term{DLE}
  \alt \term{DC1}     \sor \term{DC2} \sor \term{DC3} \sor \term{DC4} \sor \term{NAK}
  \sor \term{SYN}     \sor \term{ETB} \sor \term{CAN}
  \alt \term{EM}      \sor \term{SUB} \sor \term{ESC} \sor \term{FS}  \sor \term{GS}
  \sor \term{RS}      \sor \term{US}  \sor \term{SP}  \sor \term{DEL}
}
\production{Cntrl}{
  AsciiLarge \sor \term{@} \sor \term{[} \sor \term{\bs} \sor \term{]}
  \sor \term{\caret} \sor \term{\us}
}
\production{AsciiLarge}{
  \term{A} \sor $\ldots$ \sor \term{Z}
}
\production{Gap}{
  \term{\bs} WhiteChar \many{WhiteChar} \term{\bs}
}
\end{grammar}

\subsection{Layout}
Similarly to Haskell, a Curry programmer can use layout information
to define the structure of blocks. For this purpose, we define
the indentation of a symbol as the column number indicating
the start of this symbol. The indentation of a line is the
indentation of its first symbol.\footnote{In order to determine
the exact column number, we assume a fixed-width font with
tab stops at each 8th column.}

The layout (or ``off-side'') rule applies to lists of syntactic
entities after the keywords \term{let},
\term{where}, \term{do}, or \code{of}.
In the subsequent context-free syntax,
these lists are enclosed with
curly brackets (\term{\{ \}}) and the single entities are
separated by semicolons (\term{;}). Instead of using the curly
brackets and semicolons of the context-free syntax,
a Curry programmer must specify these lists
by indentation: the indentation of a list of syntactic
entities after \term{let}, \term{where}, \code{do}, or \code{of} is the
indentation of the next symbol following the
\term{let}, \term{where}, \code{do}, \code{of}. Any item of this list
start with the same indentation as the list. Lines with only whitespaces or
an indentation greater than the indentation of the list continue
the item in its previous line. Lines with an indentation less than
the indentation of the list terminate the entire list.
Moreover, a list started by \term{let} is terminated by the
keyword \code{in}. Thus, the sentence
\begin{curry}
f x = h x where { g y = y + 1 ; h z = (g z) * 2 }
\end{curry}
which is valid w.r.t.\ the context-free syntax, is written
with the layout rules as
\begin{curry}
f x = h x
 where g y = y + 1
       h z = (g z) * 2
\end{curry}
or also as
\begin{curry}
f x = h x  where
  g y = y + 1
  h z = (g z)
          * 2
\end{curry}
To avoid an indentation of top-level declarations,
the keyword \term{module} and the end-of-file token are
assumed to start in column 0.

\subsection{Context Free Grammar}

\begin{grammar}
\production{Module}{
  \term{module} ModuleID \opt{Exports} \term{where} Block
  \extension{\alt Block}
}
\lexicon{ModuleID}

% Exports
\production{Exports}{
  \term{(} \seq{Export}{,}{n} \term{)} \extension{\margin{n \geq 0}}
}
\production{Export}{
  QFunctionName
  \alt QTypeConstrID
  \extension{\opt{\term{(} \seq{ConsLabelName}{,}{n} \term{)}} \margin{n \geq 0}}
  \alt QTypeConstrID \term{(..)}
  \alt \term{module} ModuleID
}

\extension{
\production{ConsLabelName}{LabelID \sor DataConstr}
}

% Block
\production{Block}{
  \term{\{}
  \opt{\seq{ImportDecl}{;}{k} \term{;}}
  \extension{\margtext{no fixity declarations here}}
  \nextline \phantom{\term{\{}}
  \seq{BlockDeclaration}{;}{n}
  \term{\}}
  \margin{k,n \geq 0}
}

% Import
\production{ImportDecl}{
  \term{import} \opt{\term{qualified}} ModuleID \opt{\term{as} ModuleID}
                \opt{ImportRestr}
}
\production{ImportRestr}{
  \term{(} \seq{Import}{,}{n} \term{)}
  \extension{\margin{n \geq 0}}
  \alt \term{hiding} \term{(} \seq{Import}{,}{n} \term{)}
  \extension{\margin{n \geq 0}}
}
\production{Import}{
  FunctionName
  \alt TypeConstrID
  \extension{\opt{\term{(} \seq{ConsLabelName}{,}{n} \term{)}} \margin{n \geq 0}}
  \alt TypeConstrID \term{(..)}
}

% Block Declaration
\production{BlockDeclaration}{
  TypeSynonymDecl
  \alt DataDeclaration
%   \extension{\alt NewtypeDeclaration}
%   \extension{\alt ForeignDeclaration}
  \extension{\alt FixityDeclaration}
  \alt FunctionDeclaration
}

% Type Synonym
\production{TypeSynonymDecl}{
  \term{type} SimpleType \term{=} TypeExpr
}

\production{SimpleType}{
  TypeConstrID \seq{TypeVarID}{}{n} \margin{n \geq 0}
}

\lexicon{TypeConstrID}

% Data type
\production{DataDeclaration}{
     \term{data} SimpleType \margtext{external data type}%
\alt \term{data} SimpleType \term{=} \seq{ConstrDecl}{|}{n} \margin{n > 0}
}

\production{ConstrDecl}{
       \extension{DataConstr} \seq{SimpleTypeExpr}{}{n} \margin{n \geq 0}%
\extension{
  \alt SimpleTypeExpr ConsOp TypeConsExpr
       \margtext{infix data constructor}
  \alt \extension{DataConstr} \term{\{} \seq{FieldDeclaration}{,}{n} \term{\}}\margin{n \geq 0}%
}
}

% Field labels
\production{FieldDeclaration}{
  \seq{LabelID}{,}{n} \term{::} TypeExpr \margin{n > 0}
}

\lexicon{LabelID}


% Type expression
\production{TypeExpr}{
  \extension{TypeConsExpr} \opt{\term{->} TypeExpr}
}

\extension{
\production{TypeConsExpr}{
  QTypeConstrID \seq{SimpleTypeExpr}{}{n} \margin{n > 0}
  \alt SimpleTypeExpr
}
}

\production{SimpleTypeExpr}{
       TypeVarID
  \extension{\alt QTypeConstrID}
  \alt \term{()}  \margtext{unit type}
  \alt \term{(} \seq{TypeExpr}{,}{n} \term{)} \margcomb{tuple type}{n>1}
  \alt \term{[} TypeExpr \term{]} \margtext{list type}
  \alt \term{(} TypeExpr \term{)} \margtext{parenthesized type}
}

\lexicon{TypeVarID}


% FixityDeclaration
\production{FixityDeclaration}{
  FixityKeyword Digit \seq{InfixOpID}{,}{n} \margin{n>0}
}

\production{FixityKeyword}{\term{infixl} \sor \term{infixr} \sor \term{infix}}
\lexicon{InfixOpID}


% Function Declaration
\production{FunctionDeclaration}{
  Signature \sor \extension{External} \sor Equat
}

\extension{
\production{External}{
  FunctionNames \term{external} \margtext{externally defined functions}
}}%

\production{Signature}{FunctionNames \term{::} TypeExpr}

\production{FunctionNames}{\seq{FunctionName}{,}{n} \margin{n > 0}}

\production{Equat}{
  FunLHS \term{=} Expr \opt{\term{where} LocalDefs}
  \alt FunLHS CondExprs \opt{\term{where} LocalDefs}
}

\production{FunLHS}{
  FunctionName \seq{SimplePat}{}{n} \margin{n \geq 0}
  \alt SimplePat InfixOpID SimplePat
}

\production{CondExprs}{
  \term{|} InfixExpr \term{=} Expr \opt{CondExprs}
}

% Pattern
\production{Pattern}{
  ConsPattern \opt{\extension{QConsOp} Pattern}
  \margtext{infix constructor pattern}
}

\production{ConsPattern}{
  \extension{GDataConstr} \seq{SimplePat}{}{n} \margtext{constructor pattern}
  \alt SimplePat
}

\production{SimplePat}{
  \extension{Variable}
  \alt \term{\us} \margtext{wildcard}
  \alt \extension{QDataConstr}
  \alt Literal
\extension{
  \alt \term{-}  Int
       \margtext{negative pattern}
  \alt \term{-.} Float
       \margtext{negative float pattern}%
}
  \alt \term{()}
       \margtext{empty tuple pattern}
  \alt \term{(} \seq{Pattern}{,}{n} \term{)}
       \margin{n > 1}
  \alt \term{(} Pattern \term{)}
       \extension{\margtext{parenthesized pattern}}
  \alt \term{[} \seq{Pattern}{,}{n} \term{]}
       \margin{n \geq 0}
  \alt \extension{Variable} \term{@} SimplePat
       \margtext{as-pattern}%
\extension{
  \alt \term{\~{}} SimplePat
       \margtext{irrefutable pattern}
  \alt \term{(} SimplePat QFunOp SimplePat \term{)}
       \margtext{infix functional pattern}
  \alt \term{(} QFunctionName \seq{SimplePat}{}{n} \term{)}
       \margcomb{functional pattern}{n > 0}
}
  \alt \extension{QDataConstr} \term{\{} \seq{FieldPat}{,}{n} \term{\}}
       \margcomb{labeled pattern}{n \geq 0}
}

\production{FieldPat}{QLabelID \term = Pattern}

\lexicon{QLabelID}


% Local Definitions
\production{LocalDefs}{
  \offside{ValueDeclaration}{;}{n} \margin{n > 0}
}

\production{ValueDeclaration}{
  FunctionDeclaration
  \alt PatternDeclaration
  \alt \seq{VariableID}{,}{n} \term{free} \margin{n > 0}%
  \extension{
  \alt FixityDeclaration
%   \alt ForeignDeclaration
}
}

\production{PatternDeclaration}{
  Pattern \term{=} Expr \opt{\term{where} LocalDefs}
}


% Expressions
\production{Expr}{
  InfixExpr \term{::} TypeExpr \margtext{expression type signature}
  \alt InfixExpr
}

\production{InfixExpr}{
       NoOpExpr QOp  InfixExpr \margtext{infix operator application}
  \alt \term{-}  InfixExpr \margtext{unary int minus}
  \alt \term{-.} InfixExpr \margtext{unary float minus}
  \alt NoOpExpr
}

\production{NoOpExpr}{
       \term{\bs} \seq{SimplePat}{}{n} \term{->} Expr
       \margcomb{lambda expression}{n > 0}
  \alt \term{let} LocalDefs \term{in} Expr
       \margtext{let expression}
  \alt \term{if} Expr \term{then} Expr
                                       \term{else} Expr
       \margtext{conditional}
  \alt \term{case} Expr \term{of} \offside{Alt}{;}{n}
       \margcomb{case expression}{n \geq 0}
  \alt \term{fcase} Expr \term{of} \offside{Alt}{;}{n}
       \margcomb{fcase expression}{n \geq 0}
  \alt \term{do} \term{\{} \seq{Stmt}{;}{n} \term{;} Expr \term{\}}
       \margcomb{do expression}{n \geq 0}
  \alt FunctExpr
}
\production{FunctExpr}{
       \opt{FunctExpr} BasicExpr   \margtext{function application}%
}
\production{BasicExpr}{
       QVariableID
       \margtext{variable}
  \alt \term{\us}
       \margtext{anonymous free variable}%
\extension{
  \alt QFunctionName
       \margtext{qualified function}
  \alt GDataConstr
       \margtext{general constructor}
}
  \alt Literal
  \alt \term{(} Expr \term{)}
       \margtext{parenthesized expression}
  \alt \term{(} \seq{Expr}{,}{n} \term{)}
       \margcomb{tuple}{n > 1}
  \alt \term{[} \seq{Expr}{,}{n} \term{]}
       \margcomb{finite list}{\extension{n > 0}}
  \alt \term{[} Expr \opt{\term{,} Expr}
       \term{..} \opt{Expr} \term{]}
       \margtext{arithmetic sequence}
  \alt \term{[} Expr \term{|} \seq{Qual}{,}{n} \term{]}
       \margcomb{list comprehension}{n\geq 1}
  \alt \term{(} \extension{InfixExpr QOp} \term{)}
       \margtext{left section}
  \alt \term{(} \extension{\without{\nonterm{QOp}}{\term{-}, \term{-.}} InfixExpr} \term{)}
       \margtext{right section}%
  \alt \extension{QDataConstr} \term{\{} \seq{FBind}{,}{n} \term{\}}
       \margcomb{labeled construction}{n \geq 0}
  \alt \without{BasicExpr}{\extension{QDataConstr}} \term{\{} \seq{FBind}{,}{n} \term{\}}
       \margcomb{labeled update}{n > 0}
}

\production{Alt}{
       Pattern \term{->} Expr \opt{\term{where} LocalDefs}
  \alt Pattern GdAlts                          \opt{\term{where} LocalDefs}
}

\production{GdAlts}{
  \term{|} InfixExpr \term{->} Expr \opt{GdAlts}
}

\production{FBind}{
  QLabelID \term{=} Expr
}

\production{Qual}{
       Expr
  \alt \term{let} LocalDefs
  \alt Pattern \term{<-} Expr
}

\production{Stmt}{
       Expr
  \alt \term{let} LocalDefs
  \alt Pattern \term{<-} Expr
}

\production{Literal}{
  Int \sor Char \sor String \sor Float
}

\extension{
\production{GDataConstr}{
        \term{()}
  \alt \term{[]}
  \alt \term{(,}\many{\term{,}}\term{)}
  \alt QDataConstr
}
}

\production{FunctionName}{
  FunctionID \sor \term{(}InfixOpID\term{)}
  \margtext{function}
}
\production{QFunctionName}{
  QFunctionID \sor \term{(}QInfixOpID\term{)}
  \margtext{qualified function}
}
\extension{
  \production{Variable}{
    VariableID \sor \term{(}InfixOpID\term{)}
    \margtext{variable}
  }
  \production{DataConstr}{
    DataConstrID \sor \term{(}InfixOpID\term{)}
    \margtext{constructor}
  }
  \production{QDataConstr}{
    QDataConstrID \sor \term{(}QConsOp\term{)}
    \margtext{qualified constructor}
  }

  \production{QFunOp}{
    QInfixOpID \sor \term{`}QFunctionID\term{`}
    \margtext{qualified function operator}
  }
  \production{ConsOp}{
    InfixOpID \sor \term{`}DataConstrID\term{`}
    \margtext{constructor operator}
  }
  \production{QOp}{
    QFunOp \sor QConsOp \margtext{qualified operator}
  }
  \production{QConsOp}{
    GConSym \sor \term{`}QDataConstrID\term{`}
    \margtext{qualified constructor operator}
  }
  \production{GConSym}{
    \term{:} \sor QInfixOpID \margtext{general constructor symbol}
  }
}
\end{grammar}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
