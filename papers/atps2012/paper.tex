\documentclass[english]{lni}

%\IfFileExists{latin1.sty}{\usepackage{latin1}}{\usepackage{isolatin1}}

\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}
\lstset{aboveskip=0.8ex,
        belowskip=0.8ex,
        xleftmargin=2ex,
        showstringspaces=false, % no special string space
        mathescape=true,
        flexiblecolumns=false,
        basewidth=0.52em,
        basicstyle=\small\ttfamily}
\lstset{literate={->}{{$\rightarrow{}\!\!\!$}}3
       }
\lstnewenvironment{curry}{}{}
\newcommand{\listline}{\vrule width0pt depth1.75ex}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\ccode}[1]{``\code{#1}''}

\author{
Michael Hanus
\quad
Bj{\"o}rn Peem{\"o}ller
\quad
Fabian Reck \\
\\
Institut f\"ur Informatik, CAU Kiel, D-24098 Kiel, Germany \\
\texttt{\{mh|bjp|fre\}@informatik.uni-kiel.de}
}
\title{Search Strategies for Functional Logic Programming}
\begin{document}
\maketitle

\begin{abstract}
In this paper we discuss our practical experiences
with the use of different search strategies
in functional logic programs.
In particular, we show that complete strategies,
like breadth-first search or iterative deepening search,
are a reasonable alternative to incomplete strategies, like depth-first
search, that have been favored in the past for logic programming.
\end{abstract}

\section{Introduction}

Functional logic languages combine the most important
features of functional and logic programming in a single language
(see \cite{AntoyHanus10CACM,Hanus07ICLP} for recent surveys).
In particular, they provide higher-order functions and demand-driven
evaluation from functional programming together with logic programming features
like non-deterministic search and computing with partial information
(logic variables).
This combination
led to new design patterns \cite{AntoyHanus02FLOPS,AntoyHanus11WFLP}
and better abstractions for application programming,
e.g., as shown for programming with databases
\cite{BrasselHanusMueller08PADL,Fischer05},
GUI programming \cite{Hanus00PADL},
web programming \cite{Hanus01PADL,Hanus06PPDP,HanusKoschnicke10PADL},
or string parsing \cite{CaballeroLopez99}.
Moreover, it is also a good basis
to teach the ideas of functional and logic programming,
or declarative programming in general,
with a single computation model and programming language
\cite{Hanus97DPLE}.

An important feature of logic programming languages
is non-deterministic search.
In Prolog, which is still the standard language for logic programming,
non-deterministic search is implemented via backtracking,
which corresponds to a depth-first search traversal
through the SLD proof tree \cite{Lloyd87}.
Due to this feature of Prolog,
logic programming is often considered as unification and backtracking
as shown by approaches to add logic programming features
to existing functional languages
(e.g., \cite{ClaessenLjungloef00,Hinze01}).
This limited ``backtracking'' view of logic programming
is also harmful to beginners when newbies
define their family relationships using a Prolog rule like
\begin{lstlisting}
sibling(X,Y) :- sibling(Y,X).
\end{lstlisting}
In such cases, one has to explain from the beginning
the pitfalls of backtracking.
From a declarative point of view,
a logic program defines a set of rules
and a logic programming system tries to find
a solution to a query w.r.t.\ the set of rules.
In order to abstract from operational details,
the search strategy has to be complete.
Due to these considerations,
the functional logic language Curry \cite{Hanus06Curry}
does not fix a particular search strategy
so that different Curry implementations can support
different (or also several) search strategies.
Moreover, Curry implementations also
support encapsulated search
where non-deterministic computations are represented
in a data structure so that different search strategies
can be implemented as tree traversals
\cite{BrasselHanusHuch04JFLP,HanusSteiner98PLILP,Lux99FLOPS}.

In this paper, we present our practical results
with different search strategies implemented
in a new implementation of Curry, called
KiCS2 \cite{BrasselHanusPeemoellerReck11}.
KiCS2 compiles Curry programs into Haskell programs
where non-deterministic computations are implemented
as tree structures so that flexible search strategies
are supported.
Although the incomplete depth-first search strategy
is the most efficient one (provided that it is able
to find a result value),
we show that complete strategies,
like breadth-first search or iterative deepening search,
are a reasonable alternative that does not force
the programmer to consider the applied search strategy
in his program.

In the next section, we briefly recall some principles
of functional logic programming and the programming language Curry
that are necessary to understand the remaining part of the paper.
Different search strategies and their implementation
are discussed in Section~\ref{sec:strategies}.
These strategies are evaluated with a number of benchmarks
in Section~\ref{sec:benchmarks}
before we conclude in Section~\ref{sec:conclusions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Functional Logic Programming and Curry}

Curry \cite{Hanus06Curry}
is a declarative multi-paradigm language combining features 
from functional programming (demand-driven evaluation, parametric
polymorphism, higher-order functions) and logic programming
(computing with partial information, unification, constraints).
Recent surveys are available in \cite{AntoyHanus10CACM,Hanus07ICLP}.
The syntax of Curry is close to Haskell \cite{PeytonJones03Haskell}.
Thus, variables and function names usually
start with lowercase letters and the names of type and data constructors
start with an uppercase letter. The application of $f$
to $e$ is denoted by juxtaposition (``$f~e$'').
In addition, Curry allows free (logic) 
variables in conditions and right-hand sides of defining rules.
The operational semantics is based on an optimal evaluation strategy
\cite{AntoyEchahedHanus00JACM} which is a conservative extension
of lazy functional programming and (concurrent) logic programming.

A Curry program consists of the definition of data types and
operations on these types. 
Note that in a functional logic language
operations might yield more than one result on the same input due to 
the logic programming features.
For instance, Curry contains a \emph{choice} operation defined by:
%
\begin{curry}
  x ? _ = x
  _ ? y = y
\end{curry}
%
Thus, the expression \ccode{0$~$?$~$1} has two values: \code{0} and \code{1}.
If expressions have more than one value, one wants to select
intended values according to some constraints,
typically in conditions of program rules.
A \emph{rule} has the form \ccode{$f~t_1\ldots{}t_n$ | $c$ = $e$}
where the (optional) condition $c$ is a \emph{constraint},
i.e., an expression of the built-in type
\code{Success}. For instance, the trivial constraint
\code{success} is a value of type \code{Success} that
denotes the always satisfiable constraint.
Thus, we say that a constraint $c$ is \emph{satisfied} if it
can be evaluated to \code{success}.
An \emph{equational constraint} $e_1 \,\code{=:=}\, e_2$ is satisfiable
if both sides $e_1$ and $e_2$ are reducible to unifiable values.
Furthermore, if $c_1$ and $c_2$ are constraints,
\code{$c_1\,$\&$\,\,c_2$} denotes their concurrent conjunction
(i.e., both argument constraints are concurrently evaluated).

As a simple example, consider the following Curry program
which defines a polymorphic 
data type for lists and operations to compute the 
concatenation of lists and the last element of a list:\footnote{Note
that lists are a built-in data type with a more convenient syntax, 
e.g., one can write \code{[x,y,z]} instead of \code{x:y:z:[]}
and \code{[a]} instead of the list type \ccode{List a}.}
%
\begin{curry}
  data List a = [] | a : List a    --[a] denotes "List a"

  -- "++" is a right-associative infix operator
  (++) :: [a] -> [a] -> [a]
  []     ++ ys = ys
  (x:xs) ++ ys = x : (xs ++ ys)

  last :: [a] -> a
  last xs | (ys ++ [z]) =:= xs
          = z                    where ys,z free
\end{curry}
%
Logic programming is supported by admitting function calls with free
variables (e.g., \code{(ys++[z])} in the rule defining \code{last})
and constraints in the condition of a defining rule. In contrast to
Prolog, free variables need to be declared explicitly to make their
scopes clear (e.g., \ccode{where ys,z free} in the example).
A conditional rule is applicable if its condition  is satisfiable.
Thus, the rule defining \code{last} states in its condition
that \code{z} is the last element of a given list
\code{xs} if there exists a list \code{ys}
such that the concatenation of \code{ys} and the one-element list
\code{[z]} is equal to the given list \code{xs}.



{\it
Mention that search strategy is not fixed
 (discuss top-level vs. encaps. search)}

\section{Search Strategies}
\label{sec:strategies}

Show enacpsulated search, i.e., introduce search tree
and implementation of search strategies in search trees
(maybe BFS and IDS in the appendix).

\section{Benchmarks}
\label{sec:benchmarks}

Compare DFS, BFS, IDS (top-level and encapsulated, all solutions and first sol)

Hopefully, they show what we want...

\section{Conclusions}
\label{sec:conclusions}

Complete strategies could be the default!

If efficiency important and DFS safe (e.g., finite search space): use DFS

Future work: approximate safeness of DFS


\bibliography{mh}
%\bibliography{paper}

\end{document}
